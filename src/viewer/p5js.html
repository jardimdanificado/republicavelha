<!DOCTYPE html>
<html>

<head>
	<style>
		html, body 
		{
			border: 0px; 
			margin: 0px;
			padding: 0px;
			height: 100%;
			width: 100%;
			font-family:'Lucida Console', monospace;
			font-size: 80%;
			white-space: nowrap;
		}
		canvas
		{
			display: block;
			position: absolute;
			left: 0;
			top: 0;
		}
	</style>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>republicavelha</title>
	<link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
</head>

<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js""></script>
	<script>

		function getColorTheme(currentTheme,sfactor)
		{
			let letra = (['rgb', 'rbg', 'grb', 'gbr', 'brg', 'bgr'])[currentTheme].split('');
			let rgb = 
			{
				r:sfactor*30,
				g:255-sfactor*15,
				b:0
			};
			return[rgb[letra[0]],rgb[letra[1]],rgb[letra[2]]];
		}

		var getMap = async (fn,args)=>
		{
			return fn.apply(this,args);
		}

		function cyclePosition(camera,suboradd=0)
		{
			const posit = 
			[
				{
					position:
					{
						x:0,
						y:0
					},
					target:
					{
						x:camera.map.length*5,
						y:camera.map[0].length*5
					}
				},
				{
					position:
					{
						x:0,
						y:camera.map[0].length*5/2
					},
					target:
					{
						x:camera.map.length*5,
						y:camera.map.length*5/2
					}
				},
				{
					position:
					{
						x:0,
						y:camera.map[0].length*5
					},
					target:
					{
						x:camera.map.length*5,
						y:0
					}
				},
				{
					position:
					{
						x:camera.map.length*5/2,
						y:camera.map[0].length*5
					},
					target:
					{
						x:camera.map.length*5/2,
						y:0
					}
				},
				{
					position:
					{
						x:camera.map.length*5,
						y:camera.map[0].length*5
					},
					target:
					{
						x:0,
						y:0
					}
				},
				{
					position:
					{
						x:camera.map.length*5,
						y:camera.map[0].length*5/2
					},
					target:
					{
						x:0,
						y:camera.map[0].length*5/2
					}
				},
				{
					position:
					{
						x:camera.map.length*5,
						y:0
					},
					target:
					{
						x:0,
						y:camera.map[0].length*5
					}
				},
				{
					position:
					{
						x:camera.map.length*5/2,
						y:0
					},
					target:
					{
						x:camera.map.length*5/2,
						y:camera.map[0].length*5
					}
				},
			]
			if(suboradd == 'sub'||suboradd == 0)
			{
				if(camera.currentPosition==0)
					camera.currentPosition = 7;
				else
					camera.currentPosition--;
			}
			else
			{
				if(camera.currentPosition==7)
					camera.currentPosition = 0;
				else
					camera.currentPosition++;
			}
			camera.position.x = posit[camera.currentPosition].position.x;
			camera.position.y = posit[camera.currentPosition].position.y;

			camera.target.x = posit[camera.currentPosition].target.x;
			camera.target.y = posit[camera.currentPosition].target.y;
			return camera;
		}

		function keyPressed() 
		{
			if (keyCode === LEFT_ARROW) 
			{
				options.camera = cyclePosition(options.camera,'sub');
			}
			else if (keyCode === RIGHT_ARROW) 
			{
				options.camera = cyclePosition(options.camera,'add');
			}
			else if (keyCode === 33) //PGUP
			{
				options.camera.position.z += 50;
			}
			else if (keyCode === 34) //PGDOWN
			{
				options.camera.position.z -= 50;
			}
			else if (keyCode === 35) //END
			{
				options.theme = (options.theme==0)?5:options.theme-1;
				
			}
			else if (keyCode === 36) //HOME
			{
				options.theme = (options.theme==5)?0:options.theme+1;
			}
			else if (keyCode === UP_ARROW) 
			{
				options.camera.target.z += 50;
			}
			else if (keyCode === DOWN_ARROW) 
			{
				options.camera.target.z -= 50;
			}
			else if (keyCode === 45)//insert
			{
				options.stroked = (options.stroked)?false:true;
				(options.stroked)?stroke(0):noStroke();
			}
			else if (keyCode === 46)//delete
			{
				options.aliased = (options.aliased)?false:true;
				(options.aliased)?setAttributes('antialias', true):setAttributes('antialias', false);;
			}
			else if (keyCode === 191)//;
			{
				options.redraw = (options.redraw)?false:true;
				(options.redraw)?wrapLoop():noLoop();
			}
			else if (keyCode === 77)//m
			{
				options.debug = (options.debug)?false:true;
			}
			else if (keyCode === 188)//,
			{
				let ref = options.framerate;
				if(ref == 1)
				{}
				else if(ref == 0)
					ref = 1;
				else
					ref -= 10
			}
			else if (keyCode === 190)//.
			{
				let ref = options.framerate;
				if(ref == 1)
					ref = 10;
				else
					ref += 10;
			}
			else if (keyCode === 222)//~
			{
				options.detailed = (options.detailed)?false:true;
			}

			if(!options.redraw)
				redraw();
		}

		function wrapLoop()
		{
			frameRate(options.framerate);
			loop();
		}

		function simplify(arr) 
		{
			let blocks = [];
			let doneY = false;
			let checkmap = new Array(arr.length);
			for (let i = 0; i < arr.length; i++) 
			{
				checkmap[i] = new Array(arr[0].length).fill(false);
			}
			for (let x = 0; x < arr.length; x++) 
			{
				for (let y = 0; y < arr[0].length; y++) 
				{
					if (checkmap[x][y]) 
					{
						continue;
					} 
					else 
					{
						let currentValue = arr[x][y];
						let currentBlock = {min: {x: x, y: y}, max: {x: x, y: y}, value: currentValue};
						let counterX = 0;
						let exit = false;
						while (exit == false) 
						{
							if (arr[x + counterX] && arr[x + counterX][y] == currentValue) 
							{
								checkmap[x + counterX][y] = true;
								counterX++;
							} 
							else 
							{
								exit = true;
							}
						}
						exit = false;
						let counterY = 0;
						while (exit == false && y + counterY < arr[0].length) 
							{
							if (arr[x][y + counterY] == currentValue) 
							{
								let checks = [];
								for (let xx = 0; xx < counterX; xx++) 
								{
									for (let yy = 0; yy < counterY; yy++) 
									{
										checks.push(arr[currentBlock.max.x + xx][currentBlock.max.y + yy] == currentValue);
									}
								}
								if(checks.reduce((accumulator, currentValue) => {return accumulator + currentValue;}, 0) == checks.length) 
								{
									for (let xx = 0; xx < counterX; xx++) 
									{
										for (let yy = 0; yy < counterY; yy++) 
										{
											checkmap[currentBlock.max.x + xx][currentBlock.max.y + yy] = true;
										}
									}
									counterY++;
								} 
								else 
								{
									exit = true;
								}
							} 
							else 
							{
								exit = true;
							}
						}
						currentBlock.max.y += counterY - 1;
						currentBlock.max.x += counterX - 1;
						exit = false;
						blocks.push(currentBlock);
					}
				}
			}
			return blocks;
		}

		var world,session = {};
		var options = 
		{
			redraw: false,
			detail:1,
			debug: true,
			framerate:1,
			theme:0,
			stroked: true,
			aliased: false,
			camera:
			{
				position:{},
				target:{},
				map:{},
				currentPosition:0,
			},
		};

		async function setup() 
		{
			if(options.debug)
				console.time('setup');
			setAttributes('antialias', false);
			createCanvas(windowWidth, windowHeight, WEBGL);
			frameRate(options.framerate);
			angleMode(DEGREES);
			
			var {main} = await import("../../index.mjs");
			var {ScaleTo,findMinMax,regraDeTres,getUniqueValues} = await import("../republicavelha/util.mjs");
			session.ScaleTo = ScaleTo;
			session.findMinMax = findMinMax;
			session.regraDeTres = regraDeTres;
			session.getUniqueValues = getUniqueValues;
			world = await getMap(main,[{w:64,h:64},2,1,1,true,true]);
			
			options.camera.map = world.map.collision;
			var {min,max} = session.findMinMax(options.camera.map);
			options.camera.max = max;
			options.camera.min = min;
			options.camera.position = 
			{
				x:options.camera.map.length*5,
				y:options.camera.map[0].length*5,
				z:options.camera.map[0][0].length*5+100
			}
			options.camera.target = 
			{
				x:0,
				y:0,
				z:(options.camera.map[0][0].length*-5)+100
			}
			if(options.camera.max<options.camera.map[0][0].length/2)
				options.extra = options.camera.map[0][0].length/8;
			else if(options.camera.max>options.camera.map[0][0].length/2)
				options.extra = -options.camera.map[0][0].length/8;
			if(!options.redraw)
				noLoop();
			if(options.debug)
				console.timeEnd('setup');
		}

		function draw() 
		{
			if(options.debug)
				console.time('frame drawn in');
			if(typeof world !== 'undefined')
			{	
				camera(
					options.camera.position.x,//x 2dhorizozntal
					options.camera.position.y,//y 2dvertical
					options.camera.position.z,//z altura
					options.camera.target.x,//taget x
					options.camera.target.y,//target y
					options.camera.target.z,//target z
					0,//direction up on z
					0,
					-1
				);
				clear();
				background(0,100,125);
				
				let colors = session.getUniqueValues(world.map.heightmap).map((elm)=>
				{
					return ({id:elm,value:session.regraDeTres(options.camera.max,255,session.ScaleTo(elm-options.camera.min,0,options.camera.max))});
				}).map((elm)=>
				{
					return({id:elm.id,value:getColorTheme(options.theme,elm.value+options.extra)});
				})

				if(options.detailed)
					for (let x = 0; x < world.map.heightmap.length; x++) 
					{
						for (let y = 0; y < world.map.heightmap[0].length; y++) 
						{
							push();
							translate(x*5, y*5,world.map.heightmap[x][y]*5);
							fill.apply(this,colors.find((elm)=> {return elm.id === world.map.heightmap[x][y]}).value);
							box(5, 5, 5);
							pop();
						}
					}
				else
				{
					let simplified = simplify(world.map.heightmap);
					console.log(simplified)
					for (let k = 0; k < simplified.length; k++) 
					{
						let boxWidth = simplified[k].max.x - simplified[k].min.x + 1;
						let boxHeight = simplified[k].max.y - simplified[k].min.y + 1;
						let boxDepth = simplified[k].value * 5;
						let centerX = (simplified[k].min.x * 5 + boxWidth / 2 * 5)-2.5;
						let centerY = (simplified[k].min.y * 5 + boxHeight / 2 * 5)-2.5;
						let centerZ = (boxDepth/2)+2.5;
						push();
						translate(centerX, centerY, centerZ);
						fill.apply(this, colors.find((elm) => 
						{
							return elm.id === simplified[k].value
						}).value);
						box(boxWidth * 5, boxHeight * 5, boxDepth);
						pop();
					}
				}
			}
			if(options.debug)
				console.timeEnd('frame drawn in');
		}

	</script>
</body>

</html>